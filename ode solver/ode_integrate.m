function [S_gl,taxis] = ode_integrate(M,K,Msl,Ksl,Mfo,n_pts,...
                                      pts_eul,...
                                      S0_gl,...
                                      F_st,tpts,...
                                      flag_case,...
                                      flag_preassembled,...
                                      R_b,R_t,H,cosgamma0,theta_in,theta_fin,epsilon_0,nu,sigma,...
                                      flag_ch,...
                                      n_sez,taglia,tol_R,tol_angle,...
                                      method_cyto,theta,alpha,tol_fix,norma_inf,t_fin,...
                                      n_step_t,downsample,...
                                      tol_stat,...
                                      N_Av,F,...
                                      B_cG,B_Ca,...
                                      nu_RG,D_R_st,k_R,R_sigma,...
                                      k_GE,D_G_st,G_sigma,...
                                      D_E_st,k_E,PDE_sigma,Beta_dark,K_m,k_cat,...
                                      E_sigma,E_vol,k_hyd,kcat_DIV_Km,k_st,...
                                      u_tent,kk_u,...
                                      v_tent,kk_v,...
                                      j_cG_max,m_cG,K_cG,f_Ca,...
                                      j_ex_sat,K_ex,...
                                      alpha_max,alpha_min,m_cyc,K_cyc,...
                                      n_Rst0,rate,...
                                      flag_restart,rst_index)
%Integrate a FEM system of type M_gl*c' + K_gl*c = F_gl(c,t)
%   M,K are the geometric \int phi_*phi_j and \int D_x,y phi_i*D_x,y phi_j
%       matrices
%   pts_eul is 3 x n_pts array giving nodal coordinates over Eul cone mesh
%   n_pts is number of nodes in geometric mesh
%   S0_gl is the nodal basis coordinates for initial value of full system
%       in a column vector ordered like
%       'Act' (R*,G*,E*)
%       'Evol' (Evol*)
%       'Msg' (cG,Ca)
%   F_st is part of the forcing term that needs to be interpolated
%       between the samples of tpts
%   flag_case is a string which is either 'Act', 'Evol', 'Msg', 'Test', 
%       indicating whether we are solving the (R*,G*,E*);(E_vol*); (cG,Ca) 
%       systems or instead doing unit tests resp
%   flag_preassembled true means that M_gl and K_gl were preassembled and
%       inverted and saved to preassembled_MK_gl.mat.  They can be loaded
%       directly rather than rebuilt.  If the flag is false, then these
%       matrices are saved to aforementioned .mat file before solving the
%       system.
%   Remaining parameters are output by data

%% Compute the volume and surface area of regions with channels 
Sigma_sl = sum(sum(Msl));
V_cn = sum(sum(M));
Sigma_fo = sum(sum(Mfo));

%% Create M_gl, K_gl
% Check to see if these matrices have already been built
switch flag_preassembled
    case false
        [M_gl,K_gl] = global_MK(M,K,Msl,Ksl,n_pts,...
                                 flag_case,...
                                 R_b,R_t,H,cosgamma0,epsilon_0,nu,sigma,...
                                 D_R_st,k_R,...
                                 D_G_st,...
                                 D_E_st,k_E,...
                                 kk_u,...
                                 kk_v,...
                                 E_vol,k_hyd,...
                                 pts_eul,...
                                 R_sigma,G_sigma,E_sigma,...
                                 nu_RG,k_GE,...
                                 rate,...
                                 V_cn);
         % Perform LU decomposition
         tic
         [M_glL,M_glU] = lu(M_gl);
         disp('LU Decomposition finished')
         toc
         
         %save('preassembled_MK_gl','M_gl','K_gl','M_glL','M_glU','-v7.3');
        
    case true
        load('preassembled_MK_gl.mat','M_gl','K_gl','M_glL','M_glU')
        
    otherwise
        error('flag_preassembled was not a valid logical')

end

%% Solve the ODE
switch method_cyto(1)
    %% ODE45 solver for M_gl*S' + K_gl*S = F(S,t)
    case 0
        % Define function handle for ODE45
        f = @(t,y) M_glU\(...
                          M_glL\(...
                            global_F(M,Msl,Mfo,n_pts,...
                                 pts_eul,...
                                 y,t,...
                                 F_st,tpts,...
                                 flag_case,...
                                 epsilon_0,nu,...
                                 flag_ch,...
                                 Sigma_sl,V_cn,Sigma_fo,...
                                 F,...
                                 B_Ca,...
                                 nu_RG,R_sigma,...
                                 k_GE,G_sigma,...
                                 E_sigma,E_vol,k_hyd,k_st,...
                                 j_cG_max,m_cG,K_cG,f_Ca,...
                                 j_ex_sat,K_ex,...
                                 alpha_max,alpha_min,m_cyc,K_cyc,...
                                 rate)...
                             -K_gl*y...
                             )...
                          );
        % Define initial value for ODE45
        y0 = S0_gl';
        
        % Build the taxis
        taxis = 0:t_fin/(n_step_t-1):t_fin;
        if size(taxis,2) ~= n_step_t
            taxis = [taxis t_fin];
            assert(size(taxis,2) == n_step_t,...
                   'Size of taxis was not n_step_t');
        end
        
        % Set options for ode45
        ode45_opts = odeset('RelTol',1e-3,...
                            'AbsTol',1e-6);%,...
                            %'OutputFcn',@(t,y,flag) myode45OutputFunc(t,y,flag));
        
        % Run ODE45
        disp('ODE45 Running...');
        tic
        [taxis,S_gl] = ode45(f,taxis,y0,ode45_opts);
        toc
        
        % Reformat solution to transpose
        taxis = taxis';
        S_gl = S_gl';
        
    
    %% Theta solver for M_gl*S' + K_gl*S = F(S,t)
    case 1
        % Parameters for assessing Cauchy convergence over below sample sizes
        n_Cauchy   = method_cyto(2);
        avg_Cauchy = method_cyto(3);
        tst_Cauchy = n_Cauchy/avg_Cauchy;
    
        % Build the taxis
        taxis = 0:t_fin/(n_step_t-1):t_fin;
        if size(taxis,2) ~= n_step_t
            taxis = [taxis t_fin];
            assert(size(taxis,2) == n_step_t,...
                   'Size of taxis was not n_step_t');
        end

        % Initialize array to store solution and include initial data
        switch flag_case
            case 'Act'
                S_gl = zeros(3*n_pts,n_step_t);
            case 'Evol'
                S_gl = zeros(n_pts,n_step_t);
            case 'Msg'
                S_gl = zeros(2*n_pts,n_step_t);
            case 'Test'
                S_gl = zeros(n_pts,n_step_t);
        end
        
        S_gl(:,1) = S0_gl;
        
        % Run solver over successive time steps
        
        %  Initialize a waitbar
        WB = waitbar(0,'Progress through time integration');
        for i=2:n_step_t
            % Update waitbar
            waitbar((i-1)/n_step_t,WB);
            
            % Initialize time values for computing forcing terms
            tpast = taxis(i-1);
            dt    = taxis(i) - tpast;
            
            % Initial guess for fixed point iteration
            s0 = S_gl(:,i-1);
            
            % Keep iterating Picard scheme until satisfactorily reached
            %  Cauchy convergence
            flag_iterate = true;
            while flag_iterate
                % Array for storing theta iterations to test if Cauchy
                Cauchy = zeros(size(S_gl,1),n_Cauchy);
                Cauchy(:,1) = s0;
            
                % Run initial samples
                for j=2:n_Cauchy
                    Cauchy(:,j) = theta_iter(M_glL,M_glU,K_gl,...
                                    S_gl(:,i-1),Cauchy(:,j-1),...
                                    tpast,dt,theta,...
                                        M,Msl,Mfo,n_pts,...
                                        pts_eul,...
                                        F_st,tpts,...
                                        flag_case,...
                                        epsilon_0,nu,...
                                        flag_ch,...
                                        Sigma_sl,V_cn,Sigma_fo,...
                                        F,...
                                        B_Ca,...
                                        nu_RG,R_sigma,...
                                        k_GE,G_sigma,...
                                        E_sigma,E_vol,k_hyd,k_st,...
                                        j_cG_max,m_cG,K_cG,f_Ca,...
                                        j_ex_sat,K_ex,...
                                        alpha_max,alpha_min,m_cyc,K_cyc,...
                                        rate);
                end
                
                    % Test if samples are Cauchy
                    flag_cauchy = cauchy_crit(Cauchy,...
                                              avg_Cauchy, norma_inf,...
                                              tol_fix);
                    if flag_cauchy
                        % s_theta is last obtained value
                        s_theta = Cauchy(:,n_Cauchy);
                      
                        % Compute next solution value
                        S_gl(:,i) = 1/theta*s_theta -...
                                    (1-theta)/theta*S_gl(:,i-1);
                      
                        flag_iterate = false;
                    else
                    % Convergence criterion was not met, so initialize for
                    %  next sequence of samples.
                        s0 = Cauchy(:,n_Cauchy); 
                    end
                  
            end
            
        end
        
        % Close the waitbar
        close(WB);
              
    otherwise
        error('Valid ODE solver was not specified by method_cyto')
end

end

function [M_gl,K_gl] = global_MK(M,K,Msl,Ksl,n_pts,...
                                 flag_case,...
                                 R_b,R_t,H,cosgamma0,epsilon_0,nu,sigma,...
                                 D_R_st,k_R,...
                                 D_G_st,...
                                 D_E_st,k_E,...
                                 kk_u,...
                                 kk_v,...
                                 E_vol,k_hyd,...
                                 pts_eul,...
                                 R_sigma,G_sigma,E_sigma,...
                                 nu_RG,k_GE,...
                                 rate,...
                                 V_cn)
% M,K,Msl,Ksl are the mass and stiffness matrices for respective domains
%  while n_pts is number of domain points
% flag_case may take on the values 'Act','Evol','Msg','Test' and indicates 
%  whether activation of (R*,G*,E*), conversion of E_s to Evol, 
%  2nd Messenger diffusion for cG and Ca, or unit testing is being 
%  performed
% The rest are params from the data sheet
% M_gl,K_gl are the matrices defining the system ODE
%% Build appropriate M_gl and K_gl by matching cases
switch flag_case
    case 'Act'
        eta0 = .5*nu*epsilon_0;
        [M_gl,K_gl] = act_assembly(M,K,n_pts,...
                                    pts_eul,...
                                    D_R_st,D_G_st,D_E_st,...
                                    k_R,k_E,...
                                    R_sigma,G_sigma,E_sigma,...
                                    nu_RG,k_GE,...
                                    rate,...
                                    eta0,V_cn);
    case 'Evol'
        [M_gl,K_gl] = Evol_assembly(M,K,...
                                     D_E_st,k_E);
    case 'Msg'
        [M_gl,K_gl] = msg_assembly(M,Msl,...
                                  K,Ksl,n_pts,...
                                  R_b,R_t,H,...
                                  nu,cosgamma0,sigma,epsilon_0,...
                                  kk_u,kk_v,...
                                  E_vol,k_hyd);
    case 'Test'
        % Interpret given M and K as the global values
        M_gl = M;
        K_gl = K;
        
    otherwise
        error('flag_case did not match acceptable cases');
    
end

end

function [forcing] = global_F(M,Msl,Mfo,n_pts,...
                                 pts_eul,...
                                 S_gl,t,...
                                 F_st,tpts,...
                                 flag_case,...
                                 epsilon_0,nu,...
                                 flag_ch,...
                                 Sigma_sl,V_cn,Sigma_fo,...
                                 F,...
                                 B_Ca,...
                                 nu_RG,R_sigma,...
                                 k_GE,G_sigma,...
                                 E_sigma,E_vol,k_hyd,k_st,...
                                 j_cG_max,m_cG,K_cG,f_Ca,...
                                 j_ex_sat,K_ex,...
                                 alpha_max,alpha_min,m_cyc,K_cyc,...
                                 rate)
% M,Msl,Mfo are the mass matrices for respective domains
%  while n_pts is number of domain points
% pts_eul are the eulerian coordinates of the nodes with respect to the
%  true cone mesh
% S_gl is a column vector defining the value of the nodal solution at this
%  instant. It has varying length depending on flag_case
% F_st varies depending on flag_case. If 'Act', then F_st is never used and
%  may be NaN. Similar with tpts. If, 'Evol', then it is G_star sampled
%  across the mesh at time instants tpts.  The value at present time is
%  then interpolated. If 'Msg', then it is E_star and formatted like
%  G_star, though used differently. If 'Test', then it is samples of the 
%  full forcing function and interpolated at the true time instants 
% flag_case may take on the values 'Act','Evol','Msg','Test' and indicates 
%  whether activation of (R*,G*,E*), conversion of E_s to Evol, 
%  2nd Messenger diffusion for cG and Ca, or unit testing is being 
%  performed
% The rest are params from the data sheet
% forcing the value of the resultant forcing term across the mesh nodes
%% Build appropriate forcing by matching cases
switch flag_case
    case 'Act'
        eta0 = .5*nu*epsilon_0;
        
        c_R = S_gl(1:n_pts);
        c_G = S_gl(n_pts + 1: 2*n_pts);
        c_E = S_gl(2*n_pts + 1:3*n_pts);
        
        
        forcing = act_forcing(c_R,c_G,c_E,t,...
                                 M,pts_eul,...
                                 R_sigma,G_sigma,E_sigma,...
                                 nu_RG,k_GE,...
                                 rate,...
                                 eta0,V_cn);
    case 'Evol'
        c_E = S_gl;
        G_star = F_st;
        
        % Interpolate the G_star value at time t
        G_star = sol_interp(G_star,tpts,t);
        
        forcing = Evol_forcing(c_E,...
                                 G_star,...
                                 M,...
                                 E_vol,...
                                 k_GE);
        
    case 'Msg'
        c_u = S_gl(1:n_pts);
        c_v = S_gl(n_pts + 1: 2*n_pts);
        
        E_star = F_st;
        
        % Interpolate the E_star value at time t
        E_star = sol_interp(E_star,tpts,t);
        
        % Compute the forcing term
        forcing = msg_forcing(c_u,c_v,...
                                 E_star,...
                                 M,Msl,Mfo,n_pts,...
                                 flag_ch,...
                                 Sigma_sl,V_cn,Sigma_fo,...
                                 nu,epsilon_0,...
                                 k_hyd,k_st,...
                                 alpha_max,alpha_min,...
                                 m_cyc,K_cyc,...
                                 E_vol,...
                                 B_Ca,F,...
                                 j_cG_max,m_cG,K_cG,f_Ca,...
                                 j_ex_sat,K_ex); 
                             
    case 'Test'
        % Interpret F_st as time samples of forcing term on mesh 
        % interpolate
        forcing = sol_interp(F_st,tpts,t);
        
        
    otherwise
        error('flag_case did not match acceptable cases');
    
end
      
      
end

function [status] = myode45OutputFunc(t,y,flag)
% Monitor the progress of the odesolver through time
%  Formatted like specified by odeset
if strcmp(flag,'init')
        status = false;
elseif isempty(flag)
    n_tpts = size(t,2);
    
    disp(['Current time: t = ' num2str(t(n_tpts))]);
    status = false;
elseif strcmp(flag,'done')
    status = false;
end
end

function [stheta_next] = theta_iter(M_glL,M_glU,K_gl,...
                                S_0,stheta_now,...
                                t,dt,theta,...
                                    M,Msl,Mfo,n_pts,...
                                    pts_eul,...
                                    F_st,tpts,...
                                    flag_case,...
                                    epsilon_0,nu,...
                                    flag_ch,...
                                    Sigma_sl,V_cn,Sigma_fo,...
                                    F,...
                                    B_Ca,...
                                    nu_RG,R_sigma,...
                                    k_GE,G_sigma,...
                                    E_sigma,E_vol,k_hyd,k_st,...
                                    j_cG_max,m_cG,K_cG,f_Ca,...
                                    j_ex_sat,K_ex,...
                                    alpha_max,alpha_min,m_cyc,K_cyc,...
                                    rate)
%Compute the next iteration of the Picard fixed point scheme.
% NOTE: This is a fixed point scheme for s_theta from S_0, not S_1 from S_0
%       S_1 may be recovered from s_1 = 1/theta*s_theta -
%                                          (1-theta)/theta*S_0

%% Initialize values
t_theta = (1-theta)*t + theta*(t+dt);

%% Compute the forcing term 
[F_gl] = global_F(M,Msl,Mfo,n_pts,...
                                 pts_eul,...
                                 stheta_now,t_theta,...
                                 F_st,tpts,...
                                 flag_case,...
                                 epsilon_0,nu,...
                                 flag_ch,...
                                 Sigma_sl,V_cn,Sigma_fo,...
                                 F,...
                                 B_Ca,...
                                 nu_RG,R_sigma,...
                                 k_GE,G_sigma,...
                                 E_sigma,E_vol,k_hyd,k_st,...
                                 j_cG_max,m_cG,K_cG,f_Ca,...
                                 j_ex_sat,K_ex,...
                                 alpha_max,alpha_min,m_cyc,K_cyc,...
                                 rate);
                             
%% Iterate to the next s_theta
stheta_next = theta*dt*(...
                       M_glU\(...
                        M_glL\(...
                               F_gl - K_gl*stheta_now ...
                              )...
                             )...
                        )+ S_0;
                             
end


