% soluzione numerica del sistema non lineare che descrive la soluzione stazionaria
function [u_ss,v_ss]=steady_state(R_b,R_t,H,theta_in,theta_fin,epsilon_0,nu,...
                                  flag_ch,...
                                  tol_stat,...
                                  B_Ca,F,...
                                  PDE_sigma,k_hyd,...
                                  u_tent,...
                                  v_tent,...
                                  j_cG_max,m_cG,K_cG,f_Ca,...
                                  j_ex_sat,K_ex,...
                                  alpha_max,alpha_min,m_cyc,K_cyc)
%% Run bisection search
j_cG_max = j_cG_max*B_Ca*F;
j_ex_sat = j_ex_sat*B_Ca*F;
eta0 = (.5*nu*epsilon_0);
% Define the interval for over which ss will be found
I = [alpha_min alpha_max]*eta0/k_hyd/PDE_sigma;
u_tent = mean(I);

% Define the functions which will solve
%  Because of subtraction loss of significant digits in inverting the
%  steady state equations, need a check device to exit out of the loop if
%  IEEE 64 precision hits capacity 
mycheck = NaN(2,1);
nrepeat = 0;
while true
    v1 = f1(u_tent,...
                R_b,R_t,H,theta_in,theta_fin,epsilon_0,nu,...
                                  flag_ch,...
                                  tol_stat,...
                                  B_Ca,F,...
                                  PDE_sigma,k_hyd,...
                                  u_tent,...
                                  v_tent,...
                                  j_cG_max,m_cG,K_cG,f_Ca,...
                                  j_ex_sat,K_ex,...
                                  alpha_max,alpha_min,m_cyc,K_cyc);
    v2 = f2(u_tent,...
                R_b,R_t,H,theta_in,theta_fin,epsilon_0,nu,...
                                  flag_ch,...
                                  tol_stat,...
                                  B_Ca,F,...
                                  PDE_sigma,k_hyd,...
                                  u_tent,...
                                  v_tent,...
                                  j_cG_max,m_cG,K_cG,f_Ca,...
                                  j_ex_sat,K_ex,...
                                  alpha_max,alpha_min,m_cyc,K_cyc);
    
    if v2 == Inf
        I = [I(1) u_tent];
    elseif (nrepeat > 1e2)||(abs(v2-v1) <= tol_stat)
        u_ss = u_tent;
        v_ss = mean([v1 v2]);
        break
    elseif v1 > v2
        I = [u_tent I(2)];
    elseif v1 < v2
        I = [I(1) u_tent];
    end
    u_tent = mean(I);
    
    % Check if code is stalling with IEEE 64 precision
    if (mycheck(1) == v1)&&(mycheck(2) == v2)
        nrepeat = nrepeat+1;
    else
        mycheck = [v1;v2];
        nrepeat = 0;
    end
end
end

function v = f1(u,...
                R_b,R_t,H,theta_in,theta_fin,epsilon_0,nu,...
                                  flag_ch,...
                                  tol_stat,...
                                  B_Ca,F,...
                                  PDE_sigma,k_hyd,...
                                  u_tent,...
                                  v_tent,...
                                  j_cG_max,m_cG,K_cG,f_Ca,...
                                  j_ex_sat,K_ex,...
                                  alpha_max,alpha_min,m_cyc,K_cyc)
% Ca_d as a function of cG_d by cyclase flux balance (mon dec)
eta0 = .5*nu*epsilon_0;

ram = k_hyd*PDE_sigma*u/eta0;
ram = (ram - alpha_min)/(alpha_max-alpha_min);
ram = ram/K_cyc^m_cyc;
v = (ram.^(-1) - K_cyc^m_cyc).^(1/m_cyc);

end

function v = f2(u,...
                R_b,R_t,H,theta_in,theta_fin,epsilon_0,nu,...
                                  flag_ch,...
                                  tol_stat,...
                                  B_Ca,F,...
                                  PDE_sigma,k_hyd,...
                                  u_tent,...
                                  v_tent,...
                                  j_cG_max,m_cG,K_cG,f_Ca,...
                                  j_ex_sat,K_ex,...
                                  alpha_max,alpha_min,m_cyc,K_cyc)
% Ca_d as a function of cG_d by ion flux balance (mon inc)
ram = j_cG_max*f_Ca/2*(u.^m_cG)./(K_cG^m_cG + u.^m_cG);
ram = ram/j_ex_sat;

% Store where trying to make Michaelis-Menten be number bigger than 1
flag_inf = (ram >= 1);

ram = ram.^(-1) - 1;
v = K_ex*ram.^(-1);

% Reset the impossible solutions to infinity
v(flag_inf) = Inf;

end
